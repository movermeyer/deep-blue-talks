#! /usr/local/bin/python
# -*- coding: utf-8 -*-

import chess
import chess.uci
from chess.uci import InfoHandler
import sys

inverted = True

pieces = {
  'K':'♔',
  'Q':'♕',
  'R':'♖',
  'B':'♗',
  'N':'♘',
  'P':'♙',
  'k':'♚',
  'q':'♛',
  'r':'♜',
  'b':'♝',
  'n':'♞',
  'p':'♟'
}

def piece(piece):
  if inverted:
    if piece.islower():
      return pieces[piece.upper()]
    else:
      return pieces[piece.lower()]
  else:
    return pieces[piece]

board = chess.Board()
moves = []
candidate_moves = 3

engine = chess.uci.popen_engine('engines/stockfish')
engine.uci()
engine.setoption({'MultiPV':candidate_moves})
info = InfoHandler()
engine.info_handlers.append(info)

def print_board(board):

  def write(string):
    sys.stdout.write(string)

  def print_rank(i):
    print str(8-i) + ' ',

  def print_files():
    print ' ',
    for col in range(8):
      print chr(97 + col),
    print

  rows = board.fen().split()[0].split('/')
  for i in range(len(rows)):
    print_rank(i)
    for symbol in rows[i]:
      if symbol in pieces:
        write(piece(symbol) + ' ')
      elif symbol in '12345678':
        write(int(symbol) * '· ')
    print
  print_files()

print_board(board)

while True:
  try:
    move_no = (len(moves) / 2) + 1
    white_turn = len(moves) % 2 == 0
    cmd = raw_input('{0}{1} '.format(move_no, '.' if white_turn else '...'))
  except EOFError:
    print
    break
  if cmd == 'resign':
    break
  elif cmd == 'moves':
    for i in range(len(moves)):
      if i % 2 == 0:
        print '{0}. {1}'.format((i / 2) + 1, moves[i]),
      else:
        print moves[i]
    print
  elif cmd == 'advice':
    engine.position(board)
    best, ponder = engine.go(depth=3,movetime=500)
    analysis_board = chess.Board(board.fen())
    analysis_board.push(best)
    print "try:", board.san(best)
    print "watch out for:", analysis_board.san(ponder)
    with info:
      for pv in info.info['pv'].values():
        print "consider:", board.san(pv[0])
  elif cmd == 'position':
    # comment on position
    print 'hmmm...'
    continue
  elif cmd == 'board':
    print_board(board)
  else:
    try:
      move = cmd
      board.push_san(move)
    except ValueError:
      print 'Invalid or ambiguous move. Try again'
      print
      continue
    print_board(board)
    moves.append(move)
    if board.is_checkmate():
      print '#checkmate'
      break
    elif board.is_check():
      print '+check'
    elif board.is_stalemate():
      print 'stalemate'
      break

engine.quit()

# try redraw
#CURSOR_UP_ONE = '\x1b[1A'
#ERASE_LINE = '\x1b[2K'
#print(CURSOR_UP_ONE + ERASE_LINE)

# ideas:
# TODO(pcattori): develop these into static vs dynamic ideas
#   eg. positional evaluation vs move evaluation
#
# opening/middlegame/endgame
  # development
    # lead in development?
    # pieces blocked off?
# king safety
  # queens on/off board
  # pawn wall
  # susceptible backrank
# light/dark square weakness
# center control
  # knight on the rim is dim
# open/closed position
  # bishop pair vs knights
# who's winning?
  # who's up in material
  # attacking chances
# piece hanging?
  # need to count defenders
  # check that its not a trap
  # check that would-be attacker is not pinned
# pin / skewer?
# pawn structure
  # isolated pawns
  # passed pawns
  # doubled pawns
# tactic detector
