#! /usr/local/bin/python
# -*- coding: utf-8 -*-

import chess
import chess.uci
from chess.uci import InfoHandler
import sys

pieces = {
  'k':'♔',
  'q':'♕',
  'r':'♖',
  'b':'♗',
  'n':'♘',
  'p':'♙',
  'K':'♚',
  'Q':'♛',
  'R':'♜',
  'B':'♝',
  'N':'♞',
  'P':'♟'
}

board = chess.Board()
moves = []
candidate_moves = 3

engine = chess.uci.popen_engine('engines/stockfish')
engine.uci()
engine.setoption({'MultiPV':candidate_moves})
info = InfoHandler()
engine.info_handlers.append(info)

def print_board(board):

  def write(string):
    sys.stdout.write(string)

  def print_rank(i):
    print str(8-i) + ' ',

  def print_files():
    print ' ',
    for col in range(8):
      print chr(97 + col),
    print

  rows = board.fen().split()[0].split('/')
  for i in range(len(rows)):
    print_rank(i)
    for symbol in rows[i]:
      if symbol in pieces:
        write(pieces[symbol] + ' ')
      elif symbol in '12345678':
        write(int(symbol) * '· ')
    print
  print_files()

print_board(board)

while True:
  try:
    cmd = raw_input('! ')
  except EOFError:
    print
    break
  if cmd == 'resign':
    break
  elif cmd == 'moves':
    for i in range(len(moves)):
      if i % 2 == 0:
        print '{0}. {1}'.format((i / 2) + 1, moves[i]),
      else:
        print moves[i]
    print
  elif cmd == 'advice':
    engine.position(board)
    best, ponder = engine.go(depth=3,movetime=500)
    analysis_board = chess.Board(board.fen())
    analysis_board.push(best)
    print "try:", board.san(best)
    print "watch out for:", analysis_board.san(ponder)
    with info:
      for pv in info.info['pv'].values():
        print "consider:", board.san(pv[0])
  elif cmd == 'position':
    # comment on position
    # king safety
      # queens on/off board
      # pawn wall
      # susceptible backrank
    # light/dark square weakness
    # center control
      # knight on the rim is dim
    # open/closed position
    # who's winning?
      # who's up in material
      # attacking chances
    # development
      # lead in development?
      # pieces blocked off?
    # piece hanging?
      # need to count defenders
      # check that its not a trap
      # check that would-be attacker is not pinned
    # pin / skewer?
    print 'hmmm...'
    continue
  elif cmd == 'board':
    print_board(board)
  else:
    try:
      move = cmd
      board.push_san(move)
    except ValueError:
      print 'Invalid or ambiguous move. Try again'
      print
      continue
    print_board(board)
    moves.append(move)
    if board.is_checkmate():
      print '#checkmate'
      break
    elif board.is_check():
      print '+check'
    elif board.is_stalemate():
      print 'stalemate'
      break

engine.quit()
